### Non-Deterministic Finite Automata

The '\*' in a regular expression is syntax for a FSA to 'loop' in a particular state.

In NFA we will have 'choices' or branching of the computation. Branching will be executed in parallel and every possible state is traversed in this computational model. It will succeed if one of the accept states that an NFA can have is acheived...while ignoring all of the wrong choices. This is thought of as 'guessing correctly'. I don't know about that, but ok.

- NFA provides a 'web', 'graph' or 'matrix' of **many** possible routes or pathways to an accept state. There are many ways to get to an accept state. There needed to be a model of computation that was more flexible than DFA. NFA allow more possiblities theoretically...to implemement many possibilities..you must run parrallel computations. You need to spawn off new processes or threads (not sure which) and communicate between the threads/processes when an answer was arrived at....which in turn than accepts that input string...therefore being a computational machine that recognizes non-deterministic languages.
- the **Transition Function** for and NFA now takes a **set of states** as an argument along with a string.

An NFA differs from a DFA in that each state can transition to zero or more other states on each input symbol, and a state can also transition to others without reading a symbol.

The NFA accepts a given input stream if there is any way to reach a final state while reading the entire input. That is, it exhibits angelic nondeterminism.

Essentially each choice is a 'spawning' of a new machine. And the NFA accepts a string input if **any** one state is accepted. Multiple spawed threads????

DFA are already considered equivalent to an NFA....but not all NFA are equivalent to DFA (????). To convert an NFA to a DFA through a **'Subset construction'**. Subset construction is a proof for 'equivalence'...For any NFA, there is a DFA that accepts the same language...thus NFA's accept exactly the regular language.

- Because the equivalent DFA might have up to q^n states...it becomes impossible to visual very quickly. Let's say an NFA has 10 states...then it is possible for the equivalent DFA to have a Million states. Luckily it's not as bad in practice as it is in theory.

NFA's process more than one potential state at a time. There is 'branching' logic involved. Union of states.

DFA can be easily written as a switch statment.

Regular Expressions can easily be converted into NFA... By implementing the 'Thompson Construction'.
We can convert an arbitrary NFA into a DFA (though the DFA may in general be exponentially larger than the NFA).
The intuition is that we make a DFA that simulates all possible executions of the NFA.

In Scanners we write regular expressions to represent the valid tokens in a language....then we write an NFA using the Thompson construction and then take that NFA and convert it into a DFA with the Subset construction. We want to end up with a DFA becuase it is easier to code.

- Tools like 'Flex' will take a regular expression and do all of the converting for us....Regex --> NFA --> DFA (DFA will be in C code)

1. FLEX (fast lexical analyzer generator) is a tool/computer program for generating lexical analyzers (scanners or lexers) written by Vern Paxson in C around 1987. It is used together with Berkeley Yacc parser generator or GNU Bison parser generator. Flex and Bison both are more flexible than Lex and Yacc and produces faster code.
   Bison produces parser from the input file provided by the user. The function yylex() is automatically generated by the flex when it is provided with a .l file and this yylex() function is expected by parser to call to retrieve tokens from current/this token stream.

'Re/Flex' will generate scanners in C++

#### Aside....epsilon?

- An epsilon transition (also epsilon move or lambda transition) allows an automaton to change its state spontaneously, i.e. without consuming an input symbol. It may appear in almost all kinds of nondeterministic automaton in formal language theory, in particular: Nondeterministic Turing machine. This automaton replaces the transition function with the one that allows the empty string Îµ as a possible input.
- Epsilon provide additional states for a given input. Additional options of state....makes visualizing the graph easier to have them (???).
- 'Epsilon Closure' is the state an input is in plus all of the possible epsilon transitions available. Represents each element in the PowerSet...Every possible combination for a given input is inside the power set.
- Power set is the 'set of all possible combinatory subsets of an NFA set....and each of those 'subsets' represents an 'Epsilon Closure'....(???).

When ever there are more than one choice in an NFA what is happeneing is that new machines are being "Spawned". New and separate computational 'enviroments'. What will see in Push Down Automa....each NFA is provided a stack...so when a new machine is spawned it also recieves its own stack.
