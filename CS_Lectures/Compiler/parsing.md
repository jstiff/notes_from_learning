# Parsing.

#### Context-Free Grammers

- these grammers are NOT accepted by FSA like we see in Regular languages.
- These recognise a larger class of languages...not modeled as a 'machine'.
  have practical applications in languages and compilier design.
- Context free grammers are used in the building of Parsers...

---

- To generate a string in the language, one begins with a string consisting of only a single start symbol, and then successively applies the rules (any number of times, in any order) to rewrite this string. This stops when we obtain a string containing only terminals.

- Terminal symbols: simular to the alphabet like in FA.

- Variable symbols: Can be replaced with a string of variables and terminals.
  - These can be replaced with the help of 'Production rules'...which dictate how variables get replaced.
  - Start Variable: starting point of the computation.

#### How computation happens...

1. Write down the 'start vaiable' as the current string.
2. Pick a variable in the current string and replace it with one of its production rules.
3. Continue step 2 until no more variables are remain.

```
Example...

             - Terminals: {0,1}
             - Variables: {S}
             - Production Rules:                ///Production Rules dicate how vaiables get replaced.
                S --> 0S1
                S --> Epsilon

```

'Production rules' are computer science's version of 'rewrite rules' found in mathmatics.
...recursive symbol substitution that will generate new symbol sequences.

The scanner will process a file of source code and return all accepted strings as tokens that are identified by their types or their 'syntactic category'....'identifiers', 'assignment operator', 'integers', etc... It will return one 'word' at a time.

- it returns the actual 'lexeme'

- for a language which is just a set of strings ...a grammer is set of rules that when fallowed can **generate** any string in that language.

- A Grammer is comprised of...

  - G = (V, T, P, S)

  V: set of Variables (non-terminal)
  T: set of Terminals
  P: set of productions
  S: start variable

  So with the 'S --> aSb | epsilon' example.
  There is one variable which is the 'S'....two terminals which are 'a' / 'b' ....the start variable is 'S' and two production rules.

  - It's convention to denote variables by Uppercase and terminals with lowercase.

  ```
  With 'S --> aSb | epsilon'... production rules. We can derive the string aaabbb by generating a 'Derivation tree'.
  We can 'substitute'  S for aSb as many times as we want and then can end it by calling Epsilon.


                                      S
                                    / | \
                                   a  S  b
                                      |
                                    / | \
                                   a  S  b
                                      |
                                    / | \
                                   a  S  b
                                      |
                                   Epsilon

    This derivation tree is a precursor to the AST that will be generated by a parser. We need something that is 'generative' in nature to proceed in the compilation process.
  ```
