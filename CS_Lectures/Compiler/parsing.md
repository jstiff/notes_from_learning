# Parsing.

#### Context-Free Grammers

- these grammers are NOT accepted by FSA like we see in Regular languages.
- These recognise a larger class of languages...not modeled as a 'machine'.
  have practical applications in languages and compilier design.
- Context free grammers are used in the building of Parsers...

---

- To generate a string in the language, one begins with a string consisting of only a single start symbol, and then successively applies the rules (any number of times, in any order) to rewrite this string. This stops when we obtain a string containing only terminals.

- Terminal symbols: simular to the alphabet like in FA. These are the characters that make up the actual content of the final sentence.

- Variable symbols (Non Terminal): Can be replaced with a string of variables and terminals.
  - Non terminals are placeholders for the terminals. We can use non terminals to generate different patterns of terminal symbols.
  - These can be replaced with the help of 'Production rules'...which dictate how variables get replaced.
  - Start Variable: starting point of the computation.

#### How computation happens...

1. Write down the 'start vaiable' as the current string. a start symbol is a special non terminal that represents the initial string that will be generated by the grammar.
2. Pick a variable in the current string and replace it with one of its production rules.
3. Continue step 2 until no more variables are remain.

```
Example...

             - Terminals: {0,1}
             - Variables: {S}
             - Production Rules:                ///Production Rules dicate how vaiables get replaced.
                S --> 0S1
                S --> Epsilon

```

'Production rules' are computer science's version of 'rewrite rules' found in mathmatics.
...recursive symbol substitution that will generate new symbol sequences.

The scanner will process a file of source code and return all accepted strings as tokens that are identified by their types or their 'syntactic category'....'identifiers', 'assignment operator', 'integers', etc... It will return one 'word' at a time.

- it returns the actual 'lexeme'

- for a language which is just a set of strings ...a grammer is set of rules that when fallowed can **generate** any string in that language.

- A Grammer is comprised of...

  - G = (V, T, P, S)

  V: set of Variables (non-terminal)
  T: set of Terminals
  P: set of productions (recursive rules)
  S: start variable

  So with the 'S --> aSb | epsilon' example.
  There is one variable which is the 'S'....two terminals which are 'a' / 'b' ....the start variable is 'S' and two production rules.

  - It's convention to denote variables by Uppercase and terminals with lowercase.

  ```
  With 'S --> aSb | epsilon'... production rules. We can derive the string aaabbb by generating a 'Derivation tree'. Parsing is 'automated' derivation based on algorithms....

  We can 'substitute'  S for aSb as many times as we want and then can end it by calling Epsilon.


                                      S
                                    / | \
                                   a  S  b
                                      |
                                    / | \
                                   a  S  b
                                      |
                                    / | \
                                   a  S  b
                                      |
                                   Epsilon

    This derivation tree is a precursor to the AST that will be generated by a parser. We need something that is 'generative' in nature to proceed in the compilation process.
  ```

  Parser is based off of algorithms that are designed to generate these trees based off of production rules and a set of strings. If it cannot derive a tree...this is what is known as a 'syntax error'.

  - The grammer for an 'even length Palidron'.
    - S --> aSa | bSb | Epsilon

```

                 Expression
                 _____________
                |            |

X12       =     abc    +   dcf

 |                |         |
identifier     idntifier  Identifier

Assign --> identifier = Expression                         Uppercase are non-terminal vaiables.
Expression --> identifier + identifier                     lowercase 'identifier' means it's a terminal value


                            Assign
                            /  \   \
                         ident  =   Expression
                         (X12)       /   |   \
                                  ident  +   ident
                                (abc)          (dcf)

                          X12   =  abc   +   dcf


```
